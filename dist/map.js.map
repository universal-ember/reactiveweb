{"version":3,"file":"map.js","sources":["../src/map.ts"],"sourcesContent":["import { createCache, getValue } from '@glimmer/tracking/primitives/cache';\nimport { assert } from '@ember/debug';\n\nimport { compatOwner } from './-private/ember-compat.ts';\n\nconst setOwner = compatOwner.setOwner;\n\n/**\n * Public API of the return value of the [[map]] utility.\n */\nexport interface MappedArray<Elements extends readonly unknown[], MappedTo> {\n  /**\n   * Array-index access to specific mapped data.\n   *\n   * If the map function hasn't ran yet on the source data, it will be ran, an cached\n   * for subsequent accesses.\n   *\n   * ```js\n   *  class Foo {\n   *    myMappedData = map(this, {\n   *      data: () => [1, 2, 3],\n   *      map: (num) => `hi, ${num}!`\n   *    });\n   *\n   *    get first() {\n   *      return this.myMappedData[0];\n   *    }\n   *  }\n   * ```\n   */\n  [index: number]: MappedTo;\n\n  /**\n   * evaluate and return an array of all mapped items.\n   *\n   * This is useful when you need to do other Array-like operations\n   * on the mapped data, such as filter, or find\n   *\n   * ```js\n   *  class Foo {\n   *    myMappedData = map(this, {\n   *      data: () => [1, 2, 3],\n   *      map: (num) => `hi, ${num}!`\n   *    });\n   *\n   *    get everything() {\n   *      return this.myMappedData.values();\n   *    }\n   *  }\n   * ```\n   */\n  values: () => { [K in keyof Elements]: MappedTo };\n\n  /**\n   * Without evaluating the map function on each element,\n   * provide the total number of elements\n   *\n   * ```js\n   *  class Foo {\n   *    myMappedData = map(this, {\n   *      data: () => [1, 2, 3],\n   *      map: (num) => `hi, ${num}!`\n   *    });\n   *\n   *    get numItems() {\n   *      return this.myMappedData.length;\n   *    }\n   *  }\n   * ```\n   */\n  length: number;\n  // ^ in TS 4.3+, this can change to get length(): number;\n  //   as a funny side-effect of changing this back to just a simple property,\n  //   type-declaration-maps work again\n\n  /**\n   * Iterate over the mapped array, lazily invoking the passed map function\n   * that was passed to [[map]].\n   *\n   * This will always return previously mapped records without re-evaluating\n   * the map function, so the default `{{#each}}` behavior in ember will\n   * be optimized on \"object-identity\". e.g.:\n   *\n   * ```js\n   *  // ...\n   *  myMappedData = map(this, {\n   *    data: () => [1, 2, 3],\n   *    map: (num) => `hi, ${num}!`\n   *  });\n   *  // ...\n   * ```\n   * ```hbs\n   *  {{#each this.myMappedData as |datum|}}\n   *     loop body only invoked for changed entries\n   *     {{datum}}\n   *  {{/each}}\n   * ```\n   *\n   * Iteration in javascript is also provided by this iterator\n   * ```js\n   *  class Foo {\n   *    myMappedData = map(this, {\n   *      data: () => [1, 2, 3],\n   *      map: (num) => `hi, ${num}!`\n   *    });\n   *\n   *    get mapAgain() {\n   *      let results = [];\n   *\n   *      for (let datum of this.myMappedData) {\n   *        results.push(datum);\n   *      }\n   *\n   *      return datum;\n   *    }\n   *  }\n   * ```\n   */\n  [Symbol.iterator](): Iterator<MappedTo>;\n}\n\n/**\n * Reactivily apply a `map` function to each element in an array,\n * persisting map-results for each object, based on identity.\n *\n * This is useful when you have a large collection of items that\n * need to be transformed into a different shape (adding/removing/modifying data/properties)\n * and you want the transform to be efficient when iterating over that data.\n *\n * A common use case where this `map` utility provides benefits over is\n * ```js\n * class MyClass {\\\n *   @cached\n *   get wrappedRecords() {\n *     return this.records.map(record => new SomeWrapper(record));\n *   }\n * }\n * ```\n *\n * Even though the above is `@cached`, if any tracked data accessed during the evaluation of `wrappedRecords`\n * changes, the entire array.map will re-run, often doing duplicate work for every unchanged item in the array.\n *\n * @return {MappedArray} an object that behaves like an array. This shouldn't be modified directly. Instead, you can freely modify the data returned by the `data` function, which should be tracked in order to benefit from this abstraction.\n *\n * @example\n *\n * ```js\n *  import { map } from 'reactiveweb/map';\n *\n *  class MyClass {\n *    wrappedRecords = map(this, {\n *      data: () => this.records,\n *      map: (record) => new SomeWrapper(record),\n *    }),\n *  }\n * ```\n */\nexport function map<Elements extends readonly unknown[], MapTo = unknown>(\n  /**\n   * parent destroyable context, usually `this`\n   */\n  destroyable: object,\n  options: {\n    /**\n     * Array of non-primitives to map over\n     *\n     * This can be class instances, plain objects, or anything supported by WeakMap's key\n     */\n    data: () => Elements;\n    /**\n     * How to transform each element from `data`,\n     * similar to if you were to use Array map yourself.\n     *\n     * This function will be called only when needed / on-demand / lazily.\n     * - if iterating over part of the data, map will only be called for the elements observed\n     * - if not iterating, map will only be called for the elements observed.\n     */\n    map: (element: Elements[0]) => MapTo;\n  }\n): MappedArray<Elements, MapTo> {\n  const { data, map } = options;\n\n  return new TrackedArrayMap(destroyable, data, map) as MappedArray<Elements, MapTo>;\n}\n\nconst AT = '__AT__';\n\n/**\n * @private\n */\nexport class TrackedArrayMap<Element = unknown, MappedTo = unknown> implements MappedArray<\n  Element[],\n  MappedTo\n> {\n  // Tells TS that we can array-index-access\n  [index: number]: MappedTo;\n\n  // these can't be real private fields\n  // until @cached is a real decorator\n  private _mapCache = new WeakMap<Element & object, MappedTo>();\n  private _dataFn: () => readonly Element[];\n  private _mapper: (element: Element) => MappedTo;\n\n  constructor(owner: object, data: () => readonly Element[], map: (element: Element) => MappedTo) {\n    setOwner(this, owner as any);\n\n    this._dataFn = data;\n    this._mapper = map;\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n\n    /**\n     * This is what allows square-bracket index-access to work.\n     *\n     * Unfortunately this means the returned value is\n     * Proxy -> Proxy -> wrapper object -> *then* the class instance\n     *\n     * Maybe JS has a way to implement array-index access, but I don't know how\n     */\n    return new Proxy(this, {\n      get(_target, property) {\n        if (typeof property === 'string') {\n          const parsed = parseInt(property, 10);\n\n          if (!isNaN(parsed)) {\n            return self[AT](parsed);\n          }\n        }\n\n        return self[property as keyof MappedArray<Element[], MappedTo>];\n      },\n      // Is there a way to do this without lying to TypeScript?\n    }) as TrackedArrayMap<Element, MappedTo>;\n  }\n\n  /**\n   * We don't want to use @cached\n   * because we support 3.28, and @cached was introduced in 4.1-4.5\n   */\n  #records = createCache(() => {\n    const data = this._dataFn();\n\n    assert(\n      `Every entry in the data passed to \\`map\\` must be an object.`,\n      data.every((datum) => typeof datum === 'object')\n    );\n\n    return data as Array<Element & object>;\n  });\n\n  get _records(): (Element & object)[] {\n    return getValue(this.#records) as (Element & object)[];\n  }\n\n  values = () => [...this];\n\n  get length() {\n    return this._records.length;\n  }\n\n  [Symbol.iterator](): Iterator<MappedTo> {\n    let i = 0;\n\n    return {\n      next: () => {\n        if (i >= this.length) {\n          return { done: true, value: null };\n        }\n\n        const value = this[AT](i);\n\n        i++;\n\n        return {\n          value,\n          done: false,\n        };\n      },\n    };\n  }\n\n  /**\n   * @private\n   *\n   * don't conflict with\n   *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at\n   */\n  [AT] = (i: number) => {\n    const record = this._records[i];\n\n    assert(\n      `Expected record to exist at index ${i}, but it did not. ` +\n        `The array item is expected to exist, because the map utility resource lazily iterates along the indices of the original array passed as data. ` +\n        `This error could happen if the data array passed to map has been mutated while iterating. ` +\n        `To resolve this error, do not mutate arrays while iteration occurs.`,\n      record\n    );\n\n    let value = this._mapCache.get(record);\n\n    if (!value) {\n      value = this._mapper(record);\n      this._mapCache.set(record, value);\n    }\n\n    return value;\n  };\n}\n"],"names":["setOwner","compatOwner","map","destroyable","options","data","TrackedArrayMap","AT","_mapCache","WeakMap","_dataFn","_mapper","constructor","owner","self","Proxy","get","_target","property","parsed","parseInt","isNaN","createCache","assert","every","datum","_records","getValue","values","length","Symbol","iterator","i","next","done","value","record","set"],"mappings":"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"}