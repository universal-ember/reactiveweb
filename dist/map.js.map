{"version":3,"file":"map.js","sources":["../src/map.ts"],"sourcesContent":["import { cached } from '@glimmer/tracking';\nimport { setOwner } from '@ember/application';\nimport { assert } from '@ember/debug';\n\n/**\n * Public API of the return value of the [[map]] utility.\n */\nexport interface MappedArray<Elements extends readonly unknown[], MappedTo> {\n  /**\n   * Array-index access to specific mapped data.\n   *\n   * If the map function hasn't ran yet on the source data, it will be ran, an cached\n   * for subsequent accesses.\n   *\n   * ```js\n   *  class Foo {\n   *    myMappedData = map(this, {\n   *      data: () => [1, 2, 3],\n   *      map: (num) => `hi, ${num}!`\n   *    });\n   *\n   *    get first() {\n   *      return this.myMappedData[0];\n   *    }\n   *  }\n   * ```\n   */\n  [index: number]: MappedTo;\n\n  /**\n   * evaluate and return an array of all mapped items.\n   *\n   * This is useful when you need to do other Array-like operations\n   * on the mapped data, such as filter, or find\n   *\n   * ```js\n   *  class Foo {\n   *    myMappedData = map(this, {\n   *      data: () => [1, 2, 3],\n   *      map: (num) => `hi, ${num}!`\n   *    });\n   *\n   *    get everything() {\n   *      return this.myMappedData.values();\n   *    }\n   *  }\n   * ```\n   */\n  values: () => { [K in keyof Elements]: MappedTo };\n\n  /**\n   * Without evaluating the map function on each element,\n   * provide the total number of elements\n   *\n   * ```js\n   *  class Foo {\n   *    myMappedData = map(this, {\n   *      data: () => [1, 2, 3],\n   *      map: (num) => `hi, ${num}!`\n   *    });\n   *\n   *    get numItems() {\n   *      return this.myMappedData.length;\n   *    }\n   *  }\n   * ```\n   */\n  length: number;\n  // ^ in TS 4.3+, this can change to get length(): number;\n  //   as a funny side-effect of changing this back to just a simple property,\n  //   type-declaration-maps work again\n\n  /**\n   * Iterate over the mapped array, lazily invoking the passed map function\n   * that was passed to [[map]].\n   *\n   * This will always return previously mapped records without re-evaluating\n   * the map function, so the default `{{#each}}` behavior in ember will\n   * be optimized on \"object-identity\". e.g.:\n   *\n   * ```js\n   *  // ...\n   *  myMappedData = map(this, {\n   *    data: () => [1, 2, 3],\n   *    map: (num) => `hi, ${num}!`\n   *  });\n   *  // ...\n   * ```\n   * ```hbs\n   *  {{#each this.myMappedData as |datum|}}\n   *     loop body only invoked for changed entries\n   *     {{datum}}\n   *  {{/each}}\n   * ```\n   *\n   * Iteration in javascript is also provided by this iterator\n   * ```js\n   *  class Foo {\n   *    myMappedData = map(this, {\n   *      data: () => [1, 2, 3],\n   *      map: (num) => `hi, ${num}!`\n   *    });\n   *\n   *    get mapAgain() {\n   *      let results = [];\n   *\n   *      for (let datum of this.myMappedData) {\n   *        results.push(datum);\n   *      }\n   *\n   *      return datum;\n   *    }\n   *  }\n   * ```\n   */\n  [Symbol.iterator](): Iterator<MappedTo>;\n}\n\n/**\n * Reactivily apply a `map` function to each element in an array,\n * persisting map-results for each object, based on identity.\n *\n * This is useful when you have a large collection of items that\n * need to be transformed into a different shape (adding/removing/modifying data/properties)\n * and you want the transform to be efficient when iterating over that data.\n *\n * A common use case where this `map` utility provides benefits over is\n * ```js\n * class MyClass {\\\n *   @cached\n *   get wrappedRecords() {\n *     return this.records.map(record => new SomeWrapper(record));\n *   }\n * }\n * ```\n *\n * Even though the above is `@cached`, if any tracked data accessed during the evaluation of `wrappedRecords`\n * changes, the entire array.map will re-run, often doing duplicate work for every unchanged item in the array.\n *\n * @return {MappedArray} an object that behaves like an array. This shouldn't be modified directly. Instead, you can freely modify the data returned by the `data` function, which should be tracked in order to benefit from this abstraction.\n *\n * @example\n *\n * ```js\n *  import { map } from 'reactiveweb/map';\n *\n *  class MyClass {\n *    wrappedRecords = map(this, {\n *      data: () => this.records,\n *      map: (record) => new SomeWrapper(record),\n *    }),\n *  }\n * ```\n */\nexport function map<Elements extends readonly unknown[], MapTo = unknown>(\n  /**\n   * parent destroyable context, usually `this`\n   */\n  destroyable: object,\n  options: {\n    /**\n     * Array of non-primitives to map over\n     *\n     * This can be class instances, plain objects, or anything supported by WeakMap's key\n     */\n    data: () => Elements;\n    /**\n     * How to transform each element from `data`,\n     * similar to if you were to use Array map yourself.\n     *\n     * This function will be called only when needed / on-demand / lazily.\n     * - if iterating over part of the data, map will only be called for the elements observed\n     * - if not iterating, map will only be called for the elements observed.\n     */\n    map: (element: Elements[0]) => MapTo;\n  }\n): MappedArray<Elements, MapTo> {\n  let { data, map } = options;\n\n  return new TrackedArrayMap(destroyable, data, map) as MappedArray<Elements, MapTo>;\n}\n\nconst AT = '__AT__';\n\n/**\n * @private\n */\nexport class TrackedArrayMap<Element = unknown, MappedTo = unknown>\n  implements MappedArray<Element[], MappedTo>\n{\n  // Tells TS that we can array-index-access\n  [index: number]: MappedTo;\n\n  // these can't be real private fields\n  // until @cached is a real decorator\n  private _mapCache = new WeakMap<Element & object, MappedTo>();\n  private _dataFn: () => readonly Element[];\n  private _mapper: (element: Element) => MappedTo;\n\n  constructor(owner: object, data: () => readonly Element[], map: (element: Element) => MappedTo) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    setOwner(this, owner as any);\n\n    this._dataFn = data;\n    this._mapper = map;\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n\n    /**\n     * This is what allows square-bracket index-access to work.\n     *\n     * Unfortunately this means the returned value is\n     * Proxy -> Proxy -> wrapper object -> *then* the class instance\n     *\n     * Maybe JS has a way to implement array-index access, but I don't know how\n     */\n    return new Proxy(this, {\n      get(_target, property) {\n        if (typeof property === 'string') {\n          let parsed = parseInt(property, 10);\n\n          if (!isNaN(parsed)) {\n            return self[AT](parsed);\n          }\n        }\n\n        return self[property as keyof MappedArray<Element[], MappedTo>];\n      },\n      // Is there a way to do this without lying to TypeScript?\n    }) as TrackedArrayMap<Element, MappedTo>;\n  }\n\n  @cached\n  get _records(): (Element & object)[] {\n    let data = this._dataFn();\n\n    assert(\n      `Every entry in the data passed to \\`map\\` must be an object.`,\n      data.every((datum) => typeof datum === 'object')\n    );\n\n    return data as Array<Element & object>;\n  }\n\n  values = () => [...this];\n\n  get length() {\n    return this._records.length;\n  }\n\n  [Symbol.iterator](): Iterator<MappedTo> {\n    let i = 0;\n\n    return {\n      next: () => {\n        if (i >= this.length) {\n          return { done: true, value: null };\n        }\n\n        let value = this[AT](i);\n\n        i++;\n\n        return {\n          value,\n          done: false,\n        };\n      },\n    };\n  }\n\n  /**\n   * @private\n   *\n   * don't conflict with\n   *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at\n   */\n  [AT] = (i: number) => {\n    let record = this._records[i];\n\n    assert(\n      `Expected record to exist at index ${i}, but it did not. ` +\n        `The array item is expected to exist, because the map utility resource lazily iterates along the indices of the original array passed as data. ` +\n        `This error could happen if the data array passed to map has been mutated while iterating. ` +\n        `To resolve this error, do not mutate arrays while iteration occurs.`,\n      record\n    );\n\n    let value = this._mapCache.get(record);\n\n    if (!value) {\n      value = this._mapper(record);\n      this._mapCache.set(record, value);\n    }\n\n    return value;\n  };\n}\n"],"names":["map","destroyable","options","data","TrackedArrayMap","AT","_mapCache","WeakMap","_dataFn","_mapper","constructor","owner","setOwner","self","Proxy","get","_target","property","parsed","parseInt","isNaN","_records","assert","every","datum","n","this","prototype","cached","values","length","Symbol","iterator","i","next","done","value","record","set"],"mappings":"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"}