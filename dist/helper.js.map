{"version":3,"file":"helper.js","sources":["../src/helper.ts"],"sourcesContent":["import { getValue } from '@glimmer/tracking/primitives/cache';\nimport { invokeHelper } from '@ember/helper';\n\nimport { DEFAULT_THUNK, normalizeThunk } from './utils.ts';\n\nimport type ClassBasedHelper from '@ember/component/helper';\nimport type { FunctionBasedHelper } from '@ember/component/helper';\nimport type { HelperLike } from '@glint/template';\nimport type { Thunk } from 'ember-resources';\n\n// Should be from\n// @glimmer/tracking/primitives/cache\ntype Cache = ReturnType<typeof invokeHelper>;\n\ntype Get<T, K, Otherwise = unknown> = K extends keyof T ? T[K] : Otherwise;\n\n/**\n * implemented with raw `invokeHelper` API, no classes from `ember-resources` used.\n *\n * -----------------------\n *\n * Enables the use of template-helpers in JavaScript\n *\n * Note that it should be preferred to use regular functions in javascript\n * whenever possible, as the runtime cost of \"things as resources\" is non-0.\n * For example, if using `@ember/component/helper` utilities, it's a common p\n * practice to split the actual behavior from the framework construct\n * ```js\n * export function plainJs() {}\n *\n * export default helper(() => plainJs())\n * ```\n * so in this case `plainJs` can be used separately.\n *\n * This differentiation makes less of a difference since\n * [plain functions as helpers](https://github.com/emberjs/rfcs/pull/756)\n * will be supported soon.\n *\n * @example\n * ```js\n * import intersect from 'ember-composable-helpers/addon/helpers/intersect';\n *\n * import { helper } from 'reactiveweb/helper';\n *\n * class Demo {\n *   @tracked listA = [...];\n *   @tracked listB = [...]\n *\n *   intersection = helper(this, intersect, () => [this.listA, this.listB])\n *\n *   toString = (array) => array.join(', ');\n * }\n * ```\n * ```hbs\n * {{this.toString this.intersection.value}}\n * ```\n */\nexport function helper<T = unknown, S = InferSignature<T>, Return = Get<S, 'Return'>>(\n  context: object,\n  helper: T,\n  thunk: Thunk = DEFAULT_THUNK\n): { value: Return } {\n  let resource: Cache;\n\n  return {\n    get value(): Return {\n      if (!resource) {\n        resource = invokeHelper(context, helper as object, () => {\n          return normalizeThunk(thunk);\n        });\n      }\n\n      // SAFETY: we want whatever the Return type is to be forwarded.\n      //         getValue could technically be undefined, but we *def*\n      //         have an invokedHelper, so we can safely defer to the helper.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return getValue<Return>(resource as any) as Return;\n    },\n  };\n}\n\ntype InferSignature<T> =\n  T extends HelperLike<infer S>\n    ? S\n    : T extends FunctionBasedHelper<infer S>\n      ? S\n      : T extends ClassBasedHelper<infer S>\n        ? S\n        : 'Signature not found';\n"],"names":["helper","context","thunk","DEFAULT_THUNK","resource","value","invokeHelper","normalizeThunk","getValue"],"mappings":";;;;AAUA;AACA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,MAAMA,CACpBC,OAAe,EACfD,MAAS,EACTE,KAAY,GAAGC,aAAa,EACT;AACnB,EAAA,IAAIC,QAAe,CAAA;EAEnB,OAAO;IACL,IAAIC,KAAKA,GAAW;MAClB,IAAI,CAACD,QAAQ,EAAE;AACbA,QAAAA,QAAQ,GAAGE,YAAY,CAACL,OAAO,EAAED,MAAM,EAAY,MAAM;UACvD,OAAOO,cAAc,CAACL,KAAK,CAAC,CAAA;AAC9B,SAAC,CAAC,CAAA;AACJ,OAAA;;AAEA;AACA;AACA;AACA;MACA,OAAOM,QAAQ,CAASJ,QAAe,CAAC,CAAA;AAC1C,KAAA;GACD,CAAA;AACH;;;;"}