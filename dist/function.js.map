{"version":3,"file":"function.js","sources":["../src/function.ts"],"sourcesContent":["import { tracked } from '@glimmer/tracking';\nimport { assert } from '@ember/debug';\nimport { associateDestroyableChild, isDestroyed, isDestroying } from '@ember/destroyable';\nimport { waitForPromise } from '@ember/test-waiters';\n\nimport { resource } from 'ember-resources';\n\nimport { getPromiseState, type State as PromiseState } from './get-promise-state.ts';\n\ninterface CallbackMeta {\n  isRetrying: boolean;\n}\n\n/**\n * Any tracked data accessed in a tracked function _before_ an `await`\n * will \"entangle\" with the function -- we can call these accessed tracked\n * properties, the \"tracked prelude\". If any properties within the tracked\n * payload  change, the function will re-run.\n *\n * ```js\n * import Component from '@glimmer/component';\n * import { tracked } from '@glimmer/tracking';\n * import { resourceFactory, resource, use } from 'ember-resources';\n * import { trackedFunction }  from 'reactiveweb/function';\n * import { on } from '@ember/modifier';\n *\n * function Request(idFn) {\n *   return resource(({use}) => {\n *     let trackedRequest = use(trackedFunction(async () => {\n *       let id = idFn();\n *       let response = await fetch(`https://swapi.dev/api/people/${id}`);\n *       let data = await response.json();\n *\n *       return data; // { name: 'Luke Skywalker', ... }\n *     }));\n *\n *     return trackedRequest;\n *   });\n * }\n *\n * class Demo extends Component {\n *   @tracked id = 1;\n *\n *   updateId = (event) => this.id = event.target.value;\n *\n *   request = use(this, Request(() => this.id));\n *\n *   // Renders \"Luke Skywalker\"\n *   <template>\n *     {{this.request.current.value.name}}\n *\n *     <input value={{this.id}} {{on 'input' this.updateId}}>\n *   </template>\n * }\n * ```\n */\nexport function trackedFunction<Return>(\n  fn: (meta: {\n    /**\n     * true when state.retry() is called, false initially\n     * and also false when tracked data changes (new initial)\n     */\n    isRetrying: boolean;\n  }) => Return\n): State<Return>;\n\n/**\n * Any tracked data accessed in a tracked function _before_ an `await`\n * will \"entangle\" with the function -- we can call these accessed tracked\n * properties, the \"tracked prelude\". If any properties within the tracked\n * payload  change, the function will re-run.\n *\n * ```js\n * import Component from '@glimmer/component';\n * import { tracked } from '@glimmer/tracking';\n * import { trackedFunction }  from 'reactiveweb/function';\n *\n * class Demo extends Component {\n *   @tracked id = 1;\n *\n *   request = trackedFunction(this, async () => {\n *     let response = await fetch(`https://swapi.dev/api/people/${this.id}`);\n *     let data = await response.json();\n *\n *     return data; // { name: 'Luke Skywalker', ... }\n *   });\n *\n *   updateId = (event) => this.id = event.target.value;\n *\n *   // Renders \"Luke Skywalker\"\n *   <template>\n *     {{this.request.value.name}}\n *\n *     <input value={{this.id}} {{on 'input' this.updateId}}>\n *   </template>\n * }\n * ```\n * _Note_, this example uses the proposed `<template>` syntax from the [First-Class Component Templates RFC][rfc-799]\n *\n * Also note that after an `await`, the `this` context should not be accessed as it could lead to\n * destruction/timing issues.\n *\n * [rfc-799]: https://github.com/emberjs/rfcs/pull/779\n *\n * @param {Object} context destroyable parent, e.g.: component instance aka \"this\"\n * @param {Function} fn the function to run with the return value available on .value\n */\nexport function trackedFunction<Return>(\n  context: object,\n  fn: (meta: {\n    /**\n     * true when state.retry() is called, false initially\n     * and also false when tracked data changes (new initial)\n     */\n    isRetrying: boolean;\n  }) => Return\n): State<Return>;\n\nexport function trackedFunction<Return>(\n  ...args: Parameters<typeof directTrackedFunction<Return>> | Parameters<typeof classUsable<Return>>\n): State<Return> {\n  if (args.length === 1) {\n    return classUsable(...args);\n  }\n\n  if (args.length === 2) {\n    return directTrackedFunction(...args);\n  }\n\n  assert('Unknown arity: trackedFunction must be called with 1 or 2 arguments');\n}\n\nconst START = Symbol.for('__reactiveweb_trackedFunction__START__');\n\nfunction classUsable<Return>(fn: (meta: CallbackMeta) => Return) {\n  const state = new State(fn);\n\n  const destroyable = resource<State<Return>>(() => {\n    state[START]();\n\n    return state;\n  });\n\n  associateDestroyableChild(destroyable, state);\n\n  return destroyable;\n}\n\nfunction directTrackedFunction<Return>(context: object, fn: (meta: CallbackMeta) => Return) {\n  const state = new State(fn);\n\n  const destroyable = resource<State<Return>>(context, () => {\n    state[START]();\n\n    return state;\n  });\n\n  associateDestroyableChild(destroyable, state);\n\n  return destroyable;\n}\n\n/**\n * State container that represents the asynchrony of a `trackedFunction`\n */\nexport class State<Value> {\n  @tracked declare promise: Value;\n\n  /**\n   * ember-async-data doesn't catch errors,\n   * so we can't rely on it to protect us from \"leaky errors\"\n   * during rendering.\n   *\n   * See also: https://github.com/qunitjs/qunit/issues/1736\n   */\n  @tracked caughtError: unknown;\n\n  #fn: (meta: CallbackMeta) => Value;\n\n  constructor(fn: (meta: CallbackMeta) => Value) {\n    this.#fn = fn;\n  }\n\n  get #state(): PromiseState<Value> {\n    return getPromiseState(this.promise);\n  }\n\n  get state(): 'PENDING' | 'RESOLVED' | 'REJECTED' | 'UNSTARTED' {\n    if (this.#state.isLoading) {\n      return 'PENDING';\n    }\n\n    if (this.#state.resolved) {\n      return 'RESOLVED';\n    }\n\n    if (this.#state.error) {\n      return 'REJECTED';\n    }\n\n    return 'UNSTARTED';\n  }\n\n  /**\n   * Initially true, and remains true\n   * until the underlying promise resolves or rejects.\n   */\n  get isPending() {\n    return this.#state.isLoading ?? false;\n  }\n\n  /**\n   * Alias for `isResolved || isRejected`\n   */\n  get isFinished() {\n    return this.isResolved || this.isRejected;\n  }\n\n  /**\n   * Alias for `isFinished`\n   * which is in turn an alias for `isResolved || isRejected`\n   */\n  get isSettled() {\n    return this.isFinished;\n  }\n\n  /**\n   * Alias for `isPending`\n   */\n  get isLoading() {\n    return this.isPending;\n  }\n\n  /**\n   * When true, the function passed to `trackedFunction` has resolved\n   */\n  get isResolved() {\n    return Boolean(this.#state.resolved);\n  }\n\n  /**\n   * Alias for `isRejected`\n   */\n  get isError() {\n    return this.isRejected;\n  }\n\n  /**\n   * When true, the function passed to `trackedFunction` has errored\n   */\n  get isRejected() {\n    return Boolean(this.#state.error ?? this.caughtError ?? false);\n  }\n\n  /**\n   * this.data may not exist yet.\n   *\n   * Additionally, prior iterations of TrackedAsyncData did\n   * not allow the accessing of data before\n   * .state === 'RESOLVED'  (isResolved).\n   *\n   * From a correctness standpoint, this is perfectly reasonable,\n   * as it forces folks to handle the states involved with async functions.\n   *\n   * The original version of `trackedFunction` did not use TrackedAsyncData,\n   * and did not have these strictnesses upon property access, leaving folks\n   * to be as correct or as fast/prototype-y as they wished.\n   *\n   * For now, `trackedFunction` will retain that flexibility.\n   */\n  get value(): Awaited<Value> | null {\n    return (this.#state.resolved as Awaited<Value>) ?? null;\n  }\n\n  /**\n   * When the function passed to `trackedFunction` throws an error,\n   * that error will be the value returned by this property\n   */\n  get error() {\n    if (this.state === 'UNSTARTED' && this.caughtError) {\n      return this.caughtError;\n    }\n\n    if (this.state !== 'REJECTED') {\n      return null;\n    }\n\n    if (this.caughtError) {\n      return this.caughtError;\n    }\n\n    return this.#state.error ?? null;\n  }\n\n  async [START]() {\n    try {\n      const promise = this._dangerousRetry({ isRetrying: false });\n\n      await waitForPromise(promise);\n    } catch (e) {\n      if (isDestroyed(this) || isDestroying(this)) return;\n      this.caughtError = e;\n    }\n  }\n\n  /**\n   * Will re-invoke the function passed to `trackedFunction`\n   * this will also re-set some properties on the `State` instance.\n   * This is the same `State` instance as before, as the `State` instance\n   * is tied to the `fn` passed to `trackedFunction`\n   *\n   * `error` or `resolvedValue` will remain as they were previously\n   * until this promise resolves, and then they'll be updated to the new values.\n   */\n  retry = async () => {\n    try {\n      /**\n       * This function has two places where it can error:\n       * - immediately when inovking `fn` (where auto-tracking occurs)\n       * - after an await, \"eventually\"\n       */\n      const promise = this._dangerousRetry({ isRetrying: true });\n\n      await waitForPromise(promise);\n    } catch (e) {\n      if (isDestroyed(this) || isDestroying(this)) return;\n      this.caughtError = e;\n    }\n  };\n\n  _dangerousRetry = async ({ isRetrying }: CallbackMeta) => {\n    if (isDestroyed(this) || isDestroying(this)) return;\n\n    // We need to invoke this before going async so that tracked properties are consumed (entangled with) synchronously\n    this.promise = this.#fn({ isRetrying });\n\n    // TrackedAsyncData interacts with tracked data during instantiation.\n    // We don't want this internal state to entangle with `trackedFunction`\n    // so that *only* the tracked data in `fn` can be entangled.\n    await Promise.resolve();\n    if (isDestroyed(this) || isDestroying(this)) return;\n\n    /**\n     * Before we await to start a new request, let's clear our error.\n     * This is detached from the tracking frame (via the above await),\n     * se the UI can update accordingly, without causing us to refetch\n     */\n    this.caughtError = null;\n    /**\n     * This looks weird, but we need to cerate the state cache if it doesn't exist already as well as prevent JIT from removing this l ine.\n     */\n    await this.#state.resolved;\n\n    return this.promise;\n  };\n}\n"],"names":["trackedFunction","args","length","classUsable","directTrackedFunction","assert","START","Symbol","for","fn","state","State","destroyable","resource","associateDestroyableChild","context","g","prototype","tracked","i","void 0","constructor","#state","getPromiseState","promise","isLoading","resolved","error","isPending","isFinished","isResolved","isRejected","isSettled","Boolean","isError","caughtError","value","_dangerousRetry","isRetrying","waitForPromise","e","isDestroyed","isDestroying","retry","Promise","resolve"],"mappings":";;;;;;;;AAsHO,SAASA,eAAeA,CAC7B,GAAGC,IAA+F,EACnF;AACf,EAAA,IAAIA,IAAI,CAACC,MAAM,KAAK,CAAC,EAAE;AACrB,IAAA,OAAOC,WAAW,CAAC,GAAGF,IAAI,CAAC;AAC7B,EAAA;AAEA,EAAA,IAAIA,IAAI,CAACC,MAAM,KAAK,CAAC,EAAE;AACrB,IAAA,OAAOE,qBAAqB,CAAC,GAAGH,IAAI,CAAC;AACvC,EAAA;EAEAI,MAAM,CAAC,qEAAqE,CAAC;AAC/E;AAEA,MAAMC,KAAK,GAAGC,MAAM,CAACC,GAAG,CAAC,wCAAwC,CAAC;AAElE,SAASL,WAAWA,CAASM,EAAkC,EAAE;AAC/D,EAAA,MAAMC,KAAK,GAAG,IAAIC,KAAK,CAACF,EAAE,CAAC;AAE3B,EAAA,MAAMG,WAAW,GAAGC,QAAQ,CAAgB,MAAM;AAChDH,IAAAA,KAAK,CAACJ,KAAK,CAAC,EAAE;AAEd,IAAA,OAAOI,KAAK;AACd,EAAA,CAAC,CAAC;AAEFI,EAAAA,yBAAyB,CAACF,WAAW,EAAEF,KAAK,CAAC;AAE7C,EAAA,OAAOE,WAAW;AACpB;AAEA,SAASR,qBAAqBA,CAASW,OAAe,EAAEN,EAAkC,EAAE;AAC1F,EAAA,MAAMC,KAAK,GAAG,IAAIC,KAAK,CAACF,EAAE,CAAC;AAE3B,EAAA,MAAMG,WAAW,GAAGC,QAAQ,CAAgBE,OAAO,EAAE,MAAM;AACzDL,IAAAA,KAAK,CAACJ,KAAK,CAAC,EAAE;AAEd,IAAA,OAAOI,KAAK;AACd,EAAA,CAAC,CAAC;AAEFI,EAAAA,yBAAyB,CAACF,WAAW,EAAEF,KAAK,CAAC;AAE7C,EAAA,OAAOE,WAAW;AACpB;;AAEA;AACA;AACA;AACO,MAAMD,KAAK,CAAQ;AAAA,EAAA;IAAAK,CAAA,CAAA,IAAA,CAAAC,SAAA,EAAA,SAAA,EAAA,CACvBC,OAAO,CAAA,CAAA;AAAA;AAAA,EAAA,QAAA,IAAAC,CAAA,CAAA,IAAA,EAAA,SAAA,CAAA,EAAAC,MAAA;AAAA,EAAA;IAAAJ,CAAA,CAAA,IAAA,CAAAC,SAAA,EAAA,aAAA,EAAA,CASPC,OAAO,CAAA,CAAA;AAAA;AAAA,EAAA,YAAA,IAAAC,CAAA,CAAA,IAAA,EAAA,aAAA,CAAA,EAAAC,MAAA;AAPR;AACF;AACA;AACA;AACA;AACA;AACA;AAGE,EAAA,GAAG;EAEHC,WAAWA,CAACZ,EAAiC,EAAE;AAC7C,IAAA,IAAI,CAAC,GAAG,GAAGA,EAAE;AACf,EAAA;EAEA,IAAI,MAAMa,GAAwB;AAChC,IAAA,OAAOC,eAAe,CAAC,IAAI,CAACC,OAAO,CAAC;AACtC,EAAA;EAEA,IAAId,KAAKA,GAAsD;AAC7D,IAAA,IAAI,IAAI,CAAC,MAAM,CAACe,SAAS,EAAE;AACzB,MAAA,OAAO,SAAS;AAClB,IAAA;AAEA,IAAA,IAAI,IAAI,CAAC,MAAM,CAACC,QAAQ,EAAE;AACxB,MAAA,OAAO,UAAU;AACnB,IAAA;AAEA,IAAA,IAAI,IAAI,CAAC,MAAM,CAACC,KAAK,EAAE;AACrB,MAAA,OAAO,UAAU;AACnB,IAAA;AAEA,IAAA,OAAO,WAAW;AACpB,EAAA;;AAEA;AACF;AACA;AACA;EACE,IAAIC,SAASA,GAAG;AACd,IAAA,OAAO,IAAI,CAAC,MAAM,CAACH,SAAS,IAAI,KAAK;AACvC,EAAA;;AAEA;AACF;AACA;EACE,IAAII,UAAUA,GAAG;AACf,IAAA,OAAO,IAAI,CAACC,UAAU,IAAI,IAAI,CAACC,UAAU;AAC3C,EAAA;;AAEA;AACF;AACA;AACA;EACE,IAAIC,SAASA,GAAG;IACd,OAAO,IAAI,CAACH,UAAU;AACxB,EAAA;;AAEA;AACF;AACA;EACE,IAAIJ,SAASA,GAAG;IACd,OAAO,IAAI,CAACG,SAAS;AACvB,EAAA;;AAEA;AACF;AACA;EACE,IAAIE,UAAUA,GAAG;IACf,OAAOG,OAAO,CAAC,IAAI,CAAC,MAAM,CAACP,QAAQ,CAAC;AACtC,EAAA;;AAEA;AACF;AACA;EACE,IAAIQ,OAAOA,GAAG;IACZ,OAAO,IAAI,CAACH,UAAU;AACxB,EAAA;;AAEA;AACF;AACA;EACE,IAAIA,UAAUA,GAAG;AACf,IAAA,OAAOE,OAAO,CAAC,IAAI,CAAC,MAAM,CAACN,KAAK,IAAI,IAAI,CAACQ,WAAW,IAAI,KAAK,CAAC;AAChE,EAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIC,KAAKA,GAA0B;AACjC,IAAA,OAAQ,IAAI,CAAC,MAAM,CAACV,QAAQ,IAAuB,IAAI;AACzD,EAAA;;AAEA;AACF;AACA;AACA;EACE,IAAIC,KAAKA,GAAG;IACV,IAAI,IAAI,CAACjB,KAAK,KAAK,WAAW,IAAI,IAAI,CAACyB,WAAW,EAAE;MAClD,OAAO,IAAI,CAACA,WAAW;AACzB,IAAA;AAEA,IAAA,IAAI,IAAI,CAACzB,KAAK,KAAK,UAAU,EAAE;AAC7B,MAAA,OAAO,IAAI;AACb,IAAA;IAEA,IAAI,IAAI,CAACyB,WAAW,EAAE;MACpB,OAAO,IAAI,CAACA,WAAW;AACzB,IAAA;AAEA,IAAA,OAAO,IAAI,CAAC,MAAM,CAACR,KAAK,IAAI,IAAI;AAClC,EAAA;AAEA,EAAA,OAAOrB,KAAK,CAAA,GAAI;IACd,IAAI;AACF,MAAA,MAAMkB,OAAO,GAAG,IAAI,CAACa,eAAe,CAAC;AAAEC,QAAAA,UAAU,EAAE;AAAM,OAAC,CAAC;MAE3D,MAAMC,cAAc,CAACf,OAAO,CAAC;IAC/B,CAAC,CAAC,OAAOgB,CAAC,EAAE;MACV,IAAIC,WAAW,CAAC,IAAI,CAAC,IAAIC,YAAY,CAAC,IAAI,CAAC,EAAE;MAC7C,IAAI,CAACP,WAAW,GAAGK,CAAC;AACtB,IAAA;AACF,EAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,KAAK,GAAG,YAAY;IAClB,IAAI;AACF;AACN;AACA;AACA;AACA;AACM,MAAA,MAAMnB,OAAO,GAAG,IAAI,CAACa,eAAe,CAAC;AAAEC,QAAAA,UAAU,EAAE;AAAK,OAAC,CAAC;MAE1D,MAAMC,cAAc,CAACf,OAAO,CAAC;IAC/B,CAAC,CAAC,OAAOgB,CAAC,EAAE;MACV,IAAIC,WAAW,CAAC,IAAI,CAAC,IAAIC,YAAY,CAAC,IAAI,CAAC,EAAE;MAC7C,IAAI,CAACP,WAAW,GAAGK,CAAC;AACtB,IAAA;EACF,CAAC;EAEDH,eAAe,GAAG,OAAO;AAAEC,IAAAA;AAAyB,GAAC,KAAK;IACxD,IAAIG,WAAW,CAAC,IAAI,CAAC,IAAIC,YAAY,CAAC,IAAI,CAAC,EAAE;;AAE7C;AACA,IAAA,IAAI,CAAClB,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC;AAAEc,MAAAA;AAAW,KAAC,CAAC;;AAEvC;AACA;AACA;AACA,IAAA,MAAMM,OAAO,CAACC,OAAO,EAAE;IACvB,IAAIJ,WAAW,CAAC,IAAI,CAAC,IAAIC,YAAY,CAAC,IAAI,CAAC,EAAE;;AAE7C;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACP,WAAW,GAAG,IAAI;AACvB;AACJ;AACA;AACI,IAAA,MAAM,IAAI,CAAC,MAAM,CAACT,QAAQ;IAE1B,OAAO,IAAI,CAACF,OAAO;EACrB,CAAC;AACH;;;;"}